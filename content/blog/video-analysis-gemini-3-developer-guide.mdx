---
title: "Video Analysis with Gemini 3.0: A Developer's Guide"
excerpt: "Learn how to build video analysis applications with Gemini 3.0. From real-time processing to batch analysis, with code examples from our production apps."
date: "2025-06-22"
category: "Tutorial"
keywords: ["Gemini 3.0", "video analysis AI", "video AI", "multimodal AI", "Google AI"]
readingTime: 10
author: "Edison Espinosa"
---

# Video Analysis with Gemini 3.0: A Developer's Guide

We built Pet Health Scan using Gemini's video analysis capabilities. Here's everything we learned.

## Why Gemini for Video?

Gemini 3.0 excels at video analysis for several reasons:
- Native video understanding (not frame-by-frame)
- Long context windows (handles full videos)
- Cost-effective compared to alternatives
- Fast inference for real-time applications

## Getting Started

### API Setup

```typescript
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-3.0-pro" });
```

### Basic Video Analysis

```typescript
async function analyzeVideo(videoBuffer: Buffer): Promise<string> {
  const videoPart = {
    inlineData: {
      data: videoBuffer.toString("base64"),
      mimeType: "video/mp4"
    }
  };

  const result = await model.generateContent([
    "Analyze this video and describe what's happening:",
    videoPart
  ]);

  return result.response.text();
}
```

## Real-World Application: Pet Health Scan

Pet Health Scan analyzes videos of pets to identify potential health issues. Here's how we built it.

### Architecture

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   iOS App    │────▶│  API Server  │────▶│  Gemini 3.0  │
│ (Record/     │     │ (Process/    │     │ (Analyze)    │
│  Upload)     │◀────│  Return)     │◀────│              │
└──────────────┘     └──────────────┘     └──────────────┘
```

### Video Upload Handler

```typescript
import { NextRequest } from "next/server";

export async function POST(request: NextRequest) {
  const formData = await request.formData();
  const video = formData.get("video") as File;

  if (!video) {
    return Response.json({ error: "No video provided" }, { status: 400 });
  }

  // Validate video
  if (!validateVideo(video)) {
    return Response.json({ error: "Invalid video format" }, { status: 400 });
  }

  // Process with Gemini
  const analysis = await analyzePetHealth(await video.arrayBuffer());

  return Response.json(analysis);
}

function validateVideo(file: File): boolean {
  const maxSize = 50 * 1024 * 1024; // 50MB
  const allowedTypes = ["video/mp4", "video/quicktime", "video/webm"];

  return file.size <= maxSize && allowedTypes.includes(file.type);
}
```

### Health Analysis Prompt

```typescript
async function analyzePetHealth(videoBuffer: ArrayBuffer): Promise<HealthAnalysis> {
  const videoPart = {
    inlineData: {
      data: Buffer.from(videoBuffer).toString("base64"),
      mimeType: "video/mp4"
    }
  };

  const prompt = `You are a veterinary assistant. Analyze this video of a pet and identify:

1. **Species and Breed** (if identifiable)
2. **Observable Behaviors** - normal or concerning
3. **Physical Observations** - posture, movement, visible symptoms
4. **Potential Health Indicators** - anything that might warrant veterinary attention
5. **Recommendations** - whether to monitor, schedule a vet visit, or seek immediate care

Be specific about what you observe in the video. Do not speculate beyond what's visible.

Return your analysis in JSON format:
{
  "species": "dog|cat|other",
  "breed": "string or null",
  "behaviors": ["list", "of", "observations"],
  "physicalObservations": ["list", "of", "observations"],
  "concerns": ["list", "of", "concerns"],
  "urgencyLevel": "none|monitor|schedule_vet|urgent",
  "recommendations": ["list", "of", "recommendations"],
  "disclaimer": "This is not a substitute for veterinary care"
}`;

  const result = await model.generateContent([prompt, videoPart]);
  const text = result.response.text();

  // Parse JSON from response
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return JSON.parse(jsonMatch[0]);
  }

  throw new Error("Failed to parse analysis");
}
```

## Advanced Techniques

### Timestamp Analysis

For long videos, get insights at specific timestamps:

```typescript
const prompt = `Analyze this video and provide observations at key timestamps.
Return in format:
{
  "timeline": [
    { "timestamp": "0:00", "observation": "..." },
    { "timestamp": "0:15", "observation": "..." }
  ],
  "summary": "..."
}`;
```

### Comparison Analysis

Compare two videos (before/after, different angles):

```typescript
async function compareVideos(video1: Buffer, video2: Buffer) {
  const result = await model.generateContent([
    "Compare these two videos and identify differences:",
    { inlineData: { data: video1.toString("base64"), mimeType: "video/mp4" } },
    { inlineData: { data: video2.toString("base64"), mimeType: "video/mp4" } }
  ]);

  return result.response.text();
}
```

### Streaming Analysis

For real-time feedback during video processing:

```typescript
async function analyzeWithStreaming(videoBuffer: Buffer) {
  const result = await model.generateContentStream([
    "Analyze this video in detail:",
    { inlineData: { data: videoBuffer.toString("base64"), mimeType: "video/mp4" } }
  ]);

  for await (const chunk of result.stream) {
    const text = chunk.text();
    // Send to client as it generates
    yield text;
  }
}
```

## Performance Optimization

### Video Preprocessing

Reduce costs and improve speed:

```typescript
import ffmpeg from "fluent-ffmpeg";

async function optimizeVideoForAnalysis(inputPath: string): Promise<string> {
  const outputPath = `/tmp/optimized-${Date.now()}.mp4`;

  return new Promise((resolve, reject) => {
    ffmpeg(inputPath)
      .videoCodec("libx264")
      .size("720x?") // Max 720p
      .fps(15) // 15fps is enough for most analysis
      .duration(60) // Limit to 60 seconds
      .output(outputPath)
      .on("end", () => resolve(outputPath))
      .on("error", reject)
      .run();
  });
}
```

### Caching

Cache analysis results for identical videos:

```typescript
import crypto from "crypto";

async function getOrAnalyze(videoBuffer: Buffer): Promise<Analysis> {
  const hash = crypto.createHash("sha256").update(videoBuffer).digest("hex");

  // Check cache
  const cached = await cache.get(`video:${hash}`);
  if (cached) return cached;

  // Analyze and cache
  const analysis = await analyzeVideo(videoBuffer);
  await cache.set(`video:${hash}`, analysis, 86400); // 24 hours

  return analysis;
}
```

## Cost Management

### Pricing (as of January 2026)

| Model | Input (per 1M tokens) | Output (per 1M tokens) |
|-------|----------------------|------------------------|
| Gemini 3.0 Pro | $1.25 | $5.00 |
| Gemini 3.0 Flash | $0.075 | $0.30 |

**Video token calculation**: Approximately 263 tokens per second of video.

**Example**: A 30-second video ≈ 7,890 tokens ≈ $0.01 with Pro, $0.0006 with Flash.

### Cost Optimization

1. **Use Flash for initial screening**, Pro for detailed analysis
2. **Truncate long videos** to relevant sections
3. **Lower resolution** when full quality isn't needed
4. **Batch similar requests** when possible

```typescript
async function analyzeWithCostOptimization(videoBuffer: Buffer) {
  // Quick screening with Flash
  const flashModel = genAI.getGenerativeModel({ model: "gemini-3.0-flash" });
  const screening = await flashModel.generateContent([
    "Does this video contain any concerning health indicators? Yes or No.",
    { inlineData: { data: videoBuffer.toString("base64"), mimeType: "video/mp4" } }
  ]);

  // Only use Pro if concerns detected
  if (screening.response.text().toLowerCase().includes("yes")) {
    const proModel = genAI.getGenerativeModel({ model: "gemini-3.0-pro" });
    return proModel.generateContent([
      "Provide detailed health analysis:",
      { inlineData: { data: videoBuffer.toString("base64"), mimeType: "video/mp4" } }
    ]);
  }

  return screening;
}
```

## Error Handling

```typescript
async function safeAnalyze(videoBuffer: Buffer) {
  try {
    return await analyzeVideo(videoBuffer);
  } catch (error) {
    if (error.message.includes("SAFETY")) {
      return { error: "Content flagged by safety filters" };
    }
    if (error.message.includes("RECITATION")) {
      return { error: "Could not process video content" };
    }
    if (error.message.includes("quota")) {
      // Retry with backoff
      await sleep(5000);
      return await analyzeVideo(videoBuffer);
    }
    throw error;
  }
}
```

## Production Checklist

- [ ] Video validation (size, format, duration)
- [ ] Rate limiting per user
- [ ] Error handling for all API responses
- [ ] Cost monitoring and alerts
- [ ] Caching for repeat analyses
- [ ] Logging for debugging
- [ ] User consent for video processing
- [ ] Data retention policy

## Need Video AI for Your Project?

We specialize in video analysis applications with Gemini.

[Discuss Your Video AI Project](/contact)

---

*AI 4U Labs builds production video AI applications. Pet Health Scan is one of 30+ apps we've shipped.*
